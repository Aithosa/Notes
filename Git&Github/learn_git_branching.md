# learn git branching
Website: https://learngitbranching.js.org/

## 基础篇
循序渐进地介绍Git主要命令

1. Git Commit
<br>一个（小型）Git 代码库, 当前有两个提交记录 —— 初始提交 C0 和其后可能包含某些有用修改的提交 C1。
```bash
git commit
```
修改了代码库，并把这些修改保存成了一个提交记录 C2。C2 的父节点是 C1，父节点是当前提交中变更的基础。
2. Git Branch
<br>Git 的分支也非常轻量。它们只是简单地指向某个提交纪录 —— 仅此而已。所以许多 Git 爱好者传颂：早建分支！多用分支！
<br>这是因为即使创建再多分的支也不会造成储存或内存上的开销，并且按逻辑分解工作到不同的分支要比维护那些特别臃肿的分支简单多了。
<br>在将分支和提交记录结合起来后，我们会看到两者如何协作。现在只要记住使用分支其实就相当于在说：“我想基于这个提交以及它所有的父提交进行新的工作。”
<br>创建一个到名为 newImage 的分支。
```bash
git branch newImage
```
<br>告诉 Git 我们想要切换到新的分支上
```bash
git checkout newImage
```
<br>试着往新分支里提交一些东西。
```bash
git commit
```
等价于
```bash
git checkout -b newImage
```

3. Git Merge
<br>如何将两个分支合并到一起。就是说我们新建一个分支，在其上开发某个新功能，开发完成后再合并回主线。
<br>先来看一下第一种方法 —— git merge。在 Git 中合并两个分支时会产生一个特殊的提交记录，它有两个父节点。翻译成自然语言相当于：“我要把这两个父节点本身及它们所有的祖先都包含进来。”
<br>我们准备了两个分支，每个分支上各有一个独有的提交。这意味着没有一个分支包含了我们修改的所有内容。咱们通过合并这两个分支来解决这个问题。
<br>我们要把 bugFix 合并到 master 里(把bugFix合并到目前所在的分支)
```bash
git merge bugFix
```
首先，master 现在指向了一个拥有两个父节点的提交记录。假如从 master 开始沿着箭头向上看，在到达起点的路上会经过所有的提交记录。这意味着 master 包含了对代码库的所有修改。↓↓↓
<br>还有，看见各个提交记录的颜色变化了吗？为了帮助学习理解，我引入了颜色搭配。每个分支都有不同的颜色，而每个提交记录的颜色是所有包含该提交记录的分支的颜色混合之后的颜色。
<br>所以，master 分支的颜色被混入到所有的提交记录，但 bugFix 没有。下面咱们让它也改变一下颜色。
<br>再把 master 分支合并到 bugFix：
```bash
git checkout bugFix;
git merge master
```
<br>因为 master 继承自 bugFix，Git 什么都不用做，只是简单地把 bugFix 移动到 master 所指向的那个提交记录。
<br>现在所有提交记录的颜色都一样了，这表明每一个分支都包含了代码库的所有修改！大功告成！

4. Git Rebase
<br>第二种合并分支的方法是 git rebase。Rebase 实际上就是取出一系列的提交记录，“复制”它们，然后在另外一个地方逐个的放下去。
<br>Rebase 的优势就是可以创造更线性的提交历史，这听上去有些难以理解。如果只允许使用 Rebase 的话，代码库的提交历史将会变得异常清晰。
还是准备了两个分支；注意当前所在的分支是 bugFix（星号标识的是当前分支）
<br>我们想要把 bugFix 分支里的工作直接移到 master 分支上。移动以后会使得两个分支的功能看起来像是按顺序开发，但实际上它们是并行开发的。
<br>咱们这次用 git rebase 实现此目标
```bash
git rebase master
```
现在 bugFix 分支上的工作在 master 的最顶端，同时我们也得到了一个更线性的提交序列。
<br>注意，提交记录 C3 依然存在（树上那个半透明的节点），而 C3' 是我们 Rebase 到 master 分支上的 C3 的副本。
<br>现在唯一的问题就是 master 还没有更新，下面咱们就来更新它吧……
<br>现在我们切换到了 master 上。把它 rebase 到 bugFix 分支上……
```bash
git rebase bugFix
```

## 高级篇
要开始介绍 Git 的超棒特性了，快来吧！
在提交树上移动

1. HEAD
<br>我们首先看一下 “HEAD”。 HEAD 是一个对当前检出记录的符号引用 —— 也就是指向你正在其基础上进行工作的提交记录。
<br>HEAD 总是指向当前分支上最近一次提交记录。大多数修改提交树的 Git 命令都是从改变 HEAD 的指向开始的。
<br>HEAD 通常情况下是指向分支名的（如 bugFix）。在你提交时，改变了 bugFix 的状态，这一变化通过 HEAD 变得可见。
```bash
git checkout C1;
git checkout master;
git commit;
git checkout C2
```
 HEAD 指向了 master，随着提交向前移动。
<br>（译者注：实际这些命令并不是真的在查看 HEAD 指向，看下一屏就了解了。如果想看 HEAD 指向，可以通过 `cat .git/HEAD` 查看， 如果 HEAD 指向的是一个引用，还可以用 `git symbolic-ref HEAD` 查看它的指向。但是该程序不支持这两个命令）

分离的 HEAD
<br>分离的 HEAD 就是让其指向了某个具体的提交记录而不是分支名。在命令执行之前的状态如下所示：
<br>HEAD -> master -> C1
<br>HEAD 指向 master， master 指向 C1
```bash
git checkout C1
```
现在变成了
<br>HEAD -> C1
<br>通过哈希值指定提交记录。每个提交记录的哈希值显示在代表提交记录的圆圈中。

2. 相对引用（^）
<br>通过指定提交记录哈希值的方式在 Git 中移动不太方便。在实际应用时，并没有像本程序中这么漂亮的可视化提交树供你参考，所以你就不得不用 `git log` 来查查看提交记录的哈希值。
<br>并且哈希值在真实的 Git 世界中也会更长（译者注：基于 SHA-1，共 40 位）。例如前一关的介绍中的提交记录的哈希值可能是 `fed2da64c0efc5293610bdd892f82a58e8cbc5d8`。舌头都快打结了吧...
<br>比较令人欣慰的是，Git 对哈希的处理很智能。你只需要提供能够唯一标识提交记录的前几个字符即可。因此我可以仅输入`fed2` 而不是上面的一长串字符。
<br>正如我前面所说，通过哈希值指定提交记录很不方便，所以 Git 引入了相对引用。这个就很厉害了!
<br>使用相对引用的话，你就可以从一个易于记忆的地方（比如 bugFix 分支或 HEAD）开始计算。
<br>相对引用非常给力，这里我介绍两个简单的用法：
    * 使用 ^ 向上移动 1 个提交记录
    * 使用 ~<num> 向上移动多个提交记录，如 ~3
(未完)

3. 相对引用2（~）
